
Say we have a point O, $\vec{u}$ and $\vec{v}\ne\vec{0}$, two vectors. 


$$
d: \overrightarrow{OM}=\vec{u}+t\vec{v}, t\in\mathbb{R}
$$

Specifically, this is the vector equation of d seen from O. 
If you draw this, you'll see that $\vec{u}$ points to a point, and from there $\vec{v}$ points, by virtue of being multiplied by any real number, to a set of points, one of which is M. M is considered a mobile point, meaning it can be any point we want, in this case any point on the line.


This also warrants the introduction of a new term: a couple.

$$
R=(A,\vec{v})
$$

A being a point of d, and $\vec{v}$ being the director vector of d.
It's a way to also find d.

The parameter t of the abscissa of M in R, is found by

$$
t=\frac{||\overrightarrow{AM}||}{||\vec{v}||}
$$

As an example, say we have the triangle ABC, we need to draw $d:\overrightarrow{BM}=\overrightarrow{BA}+t\overrightarrow{AC},t\in\mathbb{R}$. That would simply be the line of which AC is part of. The line $g:\overrightarrow{BM}=\overrightarrow{CB}+t\overrightarrow{AB}$ is the line // to AB, of which the point B+$\overrightarrow{AC}$ is part of.
If we need $h=\overrightarrow{AM}=\frac{1}{2}\overrightarrow{AB}+t\overrightarrow{BC}$ is a line // to BC, that passes through the midpoint between A and B.

## Intersections

One thing we will oft need to find will be the intersections of these lines. 

How do?

Well, say we need to find the intersection I of the lines g and h. 
We will likely be given a point from which to observe it, here we say point B (related to previous example)

What we have from that is the following:

$$
\begin{cases}
g: \overrightarrow{BM}=\overrightarrow{CB}+k\overrightarrow{AB},t\in\mathbb{R}\\
h: \overrightarrow{BM}=\frac{1}{2}\overrightarrow{BA}+t\overrightarrow{BC}
\end{cases}
$$

for I = M, we obtain the following:

$$
\begin{equation}
\begin{split}
\overrightarrow{BI}=\overrightarrow{CB}+t\overrightarrow{AB}=\frac{1}{2}\overrightarrow{BA}+s\overrightarrow{BC}\\
\iff (t+\frac{1}{2})\overrightarrow{AB}=(s+1)\overrightarrow{BC}
\end{split}
\end{equation}
$$

As AB and BC aren't colinear:

$$
\begin{cases}
t+\frac{1}{2}=0\\
s+1=0
\end{cases}
\iff
\begin{cases}
t=-\frac{1}{2}\\
s=-1
\end{cases}
$$

which means $\overrightarrow{BI}=\frac{1}{2}\overrightarrow{BA}-\overrightarrow{BC}$.



As an exercise for the reader, find the equations for the median from point A looking from point C.

> [!Note]- Solution
>  $d:\vec{CM}=\vec{CA}+t(\frac{1}{2}\vec{CB}-\vec{CA})$

As a better exercise for the reader, find the center of gravity of the triangle (as in where all the medians collide).

## Normal equation (2D only)

Say there is a point O, as well as a vector $\vec{n} (\ne \vec{0})$, the normal vector.

Say we have a line called d, described $(AM)$, as it has points A and M on it, where M is a random point, and A is the closest point to O on the line.

Knowing M, which is easy as it's a random point, we need to find $\delta$, the distance between the point and the line, which is equivalent to $||\vec{OA}||$. How do we find that?

First, we define the following:

$$
\overrightarrow{OM}\cdot\vec{n}=\alpha
$$
As well as

$$
\vec{n}\cdot\vec{AM}=0
$$

This is called the normal equation of line d seen from O.

From there, to find $\delta$, we have the following: 

$$
\delta= \frac{|\alpha|}{||\vec{n}||}
$$

Essentially, we use $\frac{\vec{v}\cdot\vec{u}}{||\vec{u}||^2}\vec{u}$, which is the formula for finding the [[2. Scalar product#Orthogonal projection|projection]] of a vector on another vector. We're projecting $\vec{OM}$ onto $\vec{n}$. This gives us $\vec{OA}$, the closest point on a line to any given point is where a perpendicular line would be that passes through that point.

We've now got $\vec{OA}$, we need it's magnitude, which is $\delta$. 
This means we can take the absolute value of the projection, which allows us to cancel some stuff out, turning it into:

$$\delta=\frac{|\vec{OM}\cdot\vec{n}|}{||\vec{n}||}$$


To explain this properly I would use a drawing, which isn't easy to implement, so if you're inconvenienced by this, remember: I'm working on it it isn't exactly trivial, if it isn't done by Saturday 11th of October please send me an email reminding me.


This allows us to find the distance between some point O, and any line.

A fun property of that is that if $||\vec{n}||=1$, so $\vec{n}$ is a unit vector, it makes it trivial, as the distance is just $|\alpha|$.


This has many uses, all of which are difficult to demonstrate, just keep this in mind if you ever need to find the distance between two things, where one is a point and the other a line.

TLDR: 

The formula to remember is:

$$
\delta=\frac{|\vec{OM}\cdot\vec{n}|}{||\vec{n}||}
$$

It finds the distance between O and a line that passes through M and is orthogonal to $\vec{n}$.

The rest of this section is more or less fluff to poorly explain why it works.

>[!tip]- A note on normal vectors and their uses
>So, normal vectors eh? 
>I've mostly glossed over it, but it's a vector, that is perpendicular to a line. Well, that's in 2D anyways 
>In 3D, it'd be the vector perpendicular to the surface, and in 4D I don't know the proper terms.
>
>They have surprisingly many uses, this being one of them. However the use that caused me to learn about them are video game graphics. What do I mean?
>Well, that requires a small tangent about how light works. Light, when it hits a surface, gets partly absorbed, and partly reflected. To determine the angle of reflection, if you've gone through this in physics or were just curious, you might know that the angle of the incoming light is at the same angle of the out-coming light, in relation to the surface vector. (I'm ignoring diffuse lighting).
>
>In video games, imagine a rock. A rock usually doesn't have a polished surface. If it had a polished surface, the light wouldn't scatter at all when hitting it, only reflecting perfectly.
>In video games, you don't want to model all of that, unless you want the players' gpus to melt down trying to process a single rock.
>Therefore, you cheat, and have a thing called a normal map. It's a texture (so an image with some color in specific places), that based on the color of each individual pixel, indicates what the normal vector of the object it is attached to is.
> >[!note]+
> >This works because color is RGB, and a vector is XYZ, so you plug the red into X, the green into Y, and the blue into Z. I'm oversimplifying but that's basically it.
> 
> This allows you to have a smooth object in a game, while having it reflect light like it's rough, without having to model each individual nook and cranny.

[[2. Scalar product|Previous]]
