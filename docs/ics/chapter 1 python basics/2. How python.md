.Python is executed line by line, from top to bottom.

So something like

```python
print("1")
print("bob")
print(3)
```

>[!tip]-
>`print()` will output the text in the parentheses. For it to be text, it needs quotes. 
>In the 3rd print here, python automatically converts the number (we'll soon learn they're called integers) into a text (string) automatically when it needs to output it. 
>Many things do this by default, but not all.
 
will output

```md
1
bob
3
```


Python has comments, to put one '#' (pound, hash, or hashtag, depends of how Bri'ish you are), which are ignored when the code is run:

```python
print("1") # print('1.5')
# print("2")
print("3")
```

will output

```md
1
3
```

Objects in python are things that have data. 

Variables are a thing (well, object) that stores data (people who know better shut up, this is a good explanation for beginners).

To declare a variable, you do the following:

```python
n = 13 # you declare a variable named n, which is equal to 13.
n = n - 1 # here, you assign to the same variable, overriding the value there previously, and replace it with n - 1, in other terms you reduce the value by one, making it 12.
print('n')
print(n)

n = "bob" # You can also completely override variables.
print(n)
```

```md
n
12
bob
```

A variable will have a type, the common ones are:

| name     | what                                                   | example          |
| -------- | ------------------------------------------------------ | ---------------- |
| int      | An integer, so something in $\mathbb{Z}$               | 1,2,-45          |
| float    | A floating point integer, so something in $\mathbb{R}$ | 35.0, $\pi$, 0.5 |
| string   | Some text                                              | "Hello world!"   |
| bool     | A boolean value, so true or false                      | True, False      |
| NoneType | None, so nothing.                                      | None             |

## Numbers

There are two types of numbers: ints, and floats. 

Ints are whole, floats are not.

Using +, -, \*, /, \*\*, you can add, subtract, multiply, divide, and exponentiate two numbers.

The output will depend on your input, with +, -, \*, and \*\* returning ints if both inputs are ints, however / will always return floats. 
You can also use // to get a whole division, which always returns an int, and % which returns the remainder of the division.

## Texts

Texts are also called strings.
You can "add" (concatenate) two stings:

```python
print("a" + "B")
```
```md
aB
```

You can "multiply" a string by an integer
```python
print("a"*5)
```
```md
aaaaa
```



## Print

`print()`, as mentioned before, writes what's in it's parentheses.

>[!info]-
>For those who know a bit about computers, it writes it to stdout

It works with most basic python types, and some more advanced ones. 
However, it won't always be able to print everything as you want it, although it will do exactly what you tell it to.

When called, it returns `None`.

print, technically all strings, but still, has so called escape characters, which are comprised of "\\" and some other character.
\\\\ is a backslash, \t is a tab, \n is a new line, \' is a single quote, and \" is a double quote.
These are the most important ones.

print also has the extra argument end, which by default is \n, which is appended to the end of the output (so by default it makes a new line at every print).

## Casting
Types can be annoying, so python often tries to cast an object from it's current type to the 'wanted' type.

the `float()` function tries turning what you gave it into a, you guessed it, float.
the `int()` into an integer
the `str()` into a string
etc...

Python often, but not always, tries to cast into the correct type. Sometimes it fails, so be careful.

An example is `print()`, which automatically casts what you give it into a string.

## Functions

Functions are a predetermined set of instructions, often with input variables (parameters) that determine what the function does exactly, and an output.

To create one, we use the `def` keyword.

Functions have 2 uses essentially, they do things, and they do the same things.

This allows us to:
1. Define specific things that are done at some point in time
2. Instead of writing the same code 5 times, just call the function 5 times instead.

Often times, we want functions to "turn into" some value (`x = some_func(y)`) , for a function to do so, we need it to return a value. To do this, we use the `return` keyword.

Example:

```python
def add_four(x):
	return x + 4
```
This function, it'll take in some value x, and add 4 to it.

### Docstrings

There is a thing most built in functions in python have, and that you can write for your own functions. It is used to describe the function and what it does

If you use the function `help()` on a function, it'll output it's docstring.

To write your own, it looks something like
```python
def add_four(x):
	""" adds 4
	
	@param x: Number to add 4 to
	@return: x + 4
	"""
	return x + 4
```

### Optional parameters

Sometimes, you don't need the user to specify something when using a function. That happens often enough, Python has a way for you to define what a parameter will be, unless the used writes otherwise.

```python
def add_number(x, y=4):
	""" adds y to x
	"""
	return x + y
```

In this version of add_four, instead of adding 4, we add some number y to  make it more versatile, but because most our users use this to add 4, by default unless the user specifies which number to add, it adds 4. 

Another example is in print, where we can set the optional parameters sep and end. 
It's slightly different however, as it has to specify which variable is being set with sep and end.

We typically prefer using arguments in the "correct order" instead of specifying, but some functions, like print, don't work like that.

## Some syntactic sugar

There are multiple things in Python that allow you to write instructions a bit easier.

Some examples include:

Multiple assignation, it assigns different things to different variables, in a single line.
```python
x, y = 10, 12
```

Operation assignment operators, do an operation, and assign it's result to self.
```python
x = 1 # this is standard
x += 1 # this takes x, and adds 1 to it.
x *= 4 # same, but multiplies by 4
x /= 3 # again same, but divides by 3
# the same exists for most operators
```

## Variable scopes

There are two types of variables: global, and local.

Global variables are defined at the root of the program. Anyone, any function, can access it.

Local variables are defined inside a function, and you can't access them outside of it. If you try to call it, it'll return undefined.

If we have  two variables named the same, one global and one local, it'll use the local one. 

This works using 'ledgers', it first looks for a variable in the local scope, then it looks in the global scope, and then it throws an error if it can't find it anywhere. 

You also can't edit x from an inner scope, for obvious reasons as it'll instead try to create a new local variable. To do so, you can use the `global` keyword.

```python
x = 42

def f_one():
	print("f1:", x)

def f_two():
	x = 3
	print("f2", x)

def f_three():
	global x
	x = 55
	print("f3", x)

print("before f1:", x)
f_one()
print("after f1:", x)
f_two()
print("after f2:", x)
f_three()
print("after f3:", x)
```

>[!note]-
>Global variables are in many cases considered as 'not very good practice', so avoid using them
>If you really want to interact with something from a greater scope from inside a function, learn to pass through references. 



[[1. Why python|Previous]]
[[3. Modularity|Next]]