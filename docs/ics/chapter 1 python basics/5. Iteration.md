
So, how to we repeat some code?

Well, we could simply copy paste the logic enough times. That'll leave us with a code that's 15Gb large and not very efficient.

We could stick it in a function, and then call the function 30'000 times, but that has the same issues.

What we do instead is use loops.

There are many types of loops, let's start with `while`:

```python
n = 3
while n > 0:
	print(n)
	n -= 1

print("Done!")
```

```md
3
2
1
Done!
```

How does this work exactly?

The program checks the value after while, and if it's True, it does what's inside the loop. After it's done, it checks the condition again, if True, it does it all again, if not, it exits the loop, and executes the code that's after it.

>[!warning]- Beware of infinite loops
> As mentioned, a while loop checks if the value in front of it is True. That can be a problem, for a variety of reasons, most the fact that the program won't exit.
> If you have to use it for some stupid reason, you can use the `break` keyword. 
> It only works on loops, and it's a bit weird in some aspects, so to avoid, but know.
> Also, most while loops that use break on a condition can be turned into while loops.

In any case, while loops are at their best when it's unclear how many times it should loop. If you, before entering the loop, have a number that is related to how many times it's going to execute, which is quite often the case, you should instead use a for loop.

Speaking of which, a loop using the `for` keyword:

```python
for i in range(5):
	print("Text")
```
```md
Text
Text
Text
```


`for` will go through some values.

range() returns an object that is iterable from it's start number to it's end number.

every iteration of the loop, `i`will take the value of the current number in range.

It's a variable, you can use it as such, though you can't really assign to it.


Anyhow, here's a slight tangent on range:

range can take up to 3 inputs:

`range(5)` will go from 0 to 4 (so 0 to n-1 for any number n)

`range(2, 5)` will go from 2 to 4 (so m to n-1 for any number m and n)

`range(5, 1, -1)` will go from 5 to 1 (so m to n+1 and iterating downwards by one. Last argument is by how much you iterate)

In other terms, it goes from the first argument included, to the second argument non included, stepping by the 3rd argument each time.

That was a tangent about `range()`, now back to `for`.


For works with any iterable object, range just happens to be a really neat one. Another one is str (string).

```python
for c in 'pizza':
	print(c)
```
```md
p
i
z
z
a
```

Here, c instead of an int like with range, is a str of length 1.

Also, iterable objects can be typically indexed.

```python
string = "this is a text"
print(string[3]) # as most things in programming, indexing starts at 0
```
```markdown
s
```

Indexing returns, well, an index of the iterated object.

[[4. Conditionality|Previous]]
[[6. Tuples|Next]]