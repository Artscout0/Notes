
An algorithm can be evaluated on two aspects:

efficiency (which we'll get to), and correctness.

Correctness is, given an algorithm, how often is it correct?

If an algorithm doesn't have 'complex' stuff like loops, it's trivial.

We can prove a loop invariant, a property that is valid for every iteration of a loop, and the validity of which at the end of the loop proves that it calculated the correct value.

The use of an invariant is done as follows:

**Initialization**: Proving the invariant is correct before the loop starts

**Maintenance**: Proving that if the invariant is true for one iteration of the loop, it's true for the next one as well.

**Termination**: If the invariant is true at the end of the loop, we deduce that the program is correct.


Example:

Say we want to solve the following geometric series:

$$\sum\limits_{k=0}^{n-1}a^{k}=1+a+a^{2}+\dots+a^{n-1}$$

Here, we have a solution:

```python
def geom_series(a, n):
	
	s = 0
	for i in range(n):
		s = s * a + 1
	
	return s
```

The invariant is: ==that at the *i*th iteration of the loop, s contains the value $\sum\limits_{k=0}^{i-1}a^{k}=1+a+a^{2}+\dots+a^{i-1}$==

Before the start of the loop, s = 0, which is correct as the sum is 0.

At the ith iteration of the loop, we have $s=\sum\limits_{k=0}^{i-1}a^{k}$. As the ith iteration consits of executing the instruction `s = s * a + i`, which is:

$$(1+a+\dots+a^{i-1})a+1=(a+a^{2}+\dots+a^i)+1=\sum\limits_{k=0}^{i}a^{k}$$


The termination is that at the end of the iterations, we have $s=\sum\limits_{k=0}^{i-1}$, which is what the loop says it's calculating.


Another example is this:

```python
def max_list(L):
	max_l = L[0]
	
	for i in range(1, len(L)):
		if L[i] > max_l:
			max_l = L[i]
	
	return max_l
```

The invariant is that at the start of the ith iteration, max_l is the largest value in the range L\[0:i\]. 

Initialization:
the list L\[0:0\] has one element, which means it's the greatest, which is also what we assigned to max_l.

Maintenance:
On each iteration, max_l is assigned: `max(max_l, L[i]) = max(L[0:i+1])`.
which is the maximum between the maximum of the previous sub-list, and the new element.

Termination:

This means at the end, max_l will have the element max(0:len(L)), so the maximum of the entire list.

While loops are a bit more complex, as you also need to prove that they eventually exit (from a math sense we consider algos that don't exit to not be algorithms).

An example we'll use for a while loop algorithm will be Euclid's algorithm.

We need to find the greatest common divider of two numbers.
Normally, at least for smaller numbers, we decompose them into primes, find the common ones, and multiply them to get the number.

In computer world, that doesn't really work because of reasons nobody really wants to get into, but essentially the entire modern world, cryptography, cybersecurity, and banking (important because we are in Switzerland) rely on the fact that finding prime numbers is compicated.


This is why we are going to use a loophole:

$gcd(a,b)=gcd(b, a \mod b)$, which I won't prove exclusively because I'm lazy.

so, using that, we can create the following algorithm:

```python
def gcd(a, b):
	
	i, k = a, b
	
	while k > 0:
		i, k = k, i % k
	
	return i
```

First, as it's a while loop, we need to prove it exits.
We need the value of k to eventually reach 0 (or a negative number.) 
On each iteration, as k is being set to `i%k`, k will will decrease.
So, eventually i will be divisible by k, which means k will be set to 0.

So, we have as the invariant $gcd(a, b)=gcd(b, a \mod b)$, which again I won't prove.
This means at every iteration, $gcd(i, k)$ will still be equal to $gcd(a, b)$.

Now, when we exit the loop, it's going to be because we reach $gcd(i, 0)$, which, as 0 is divisible by any number, means i is the gcd, meaning i is also the gcd of a and b.

[[1. Introduction to algorithms|Previous]]
[[3. Recursive algorithms|Next]]