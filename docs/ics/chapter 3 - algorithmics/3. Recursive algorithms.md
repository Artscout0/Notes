
## Wth is a recursive algorithm?

Well, to put it simply, often times to solve a problem, you need to solve another instance of the same problem.

We call it the "divide and conquer paradigm".

In programming terms, it's functions that at some point in time call themselves.

So, we'll learn the basics of it using factorials.

Now, we define factorials as $n! = n * (n-1) * (n-2) * \dots * 2 * 1$

We can redefine it as $n * (n-1)!$ in most cases, however it doesn't exactly work with 0!, which we using math and stuff define to be 1. Which is why we actually define ! as:

$$
n! = \begin{cases} n * (n-1)!&, n \ge 1 \\
 \\ 0! = 1&, n = 0
\end{cases}
$$

Which we can turn into the following code:

```python
def fact(n):
	
	if n == 0:
		return 1
	
	return n * fact(n - 1)
```

>[!warning]- A quick warning to students
> When students first learn about recursion, they try shoehorning it to solve every single problem. 
> Don't, it's rarely the best solution.

What's nice about this is that the only thing you've written true equations, as n! is by definition  n \* (n-1)!.


Another function that's quite nice is finding the nth Fibonacci number.

We can turn it into the following math:

$$
fib(n) = \begin{cases} fib(n - 1) + fib(n - 2)&, n> 1\\
1 &, n = 1 \\
0 &, n=0
\end{cases}
$$

We can turn this into code, again:

```python

def fib(n):
	
	if n == 0:
		return 0
	
	if n == 1:
		return 1
		
	return fib(n-1) + fib(n-2)
```

Now, this is a garbage implementation. It's good because it works, it's bad because it takes ages.
One of the main reasons is because you're calculating the same numbers many times. More so, the amount of times you call fib is exponential in relation to n. 
You can probably speed it up by caching the output. You can likely make it even faster by rewriting it as a loop.

You can turn a lot (but by far not all) iterative function into recursive ones, and all recursive functions into iterative ones.

Recursive algorithms have the advantage that it's easy to prove it's correct, and for many problems they are much easier to find that their iterative counterparts. 
Their main disadvantage is that they are usually much much less efficient. 

[[2. Correctness of algorithms|Previous]]