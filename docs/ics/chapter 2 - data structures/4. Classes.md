
Classes are easy. Ever wanted to create your own version of range()? Ever wanted to define your own data type? Ever needed to model something as an object?

Well, using classes you can do that easily.

To create a class:

```python
class Student:
	def __init__(self, name, surname):
		self.name = name
		self.surname =  surname
	
	def presentation(self):
		print("Hi, I'm", self.name, self.surname)
```

This will allow you to call it as follows:

```python
student = Student("John", "Doe")

student.presentation()
```

this will output

```md
Hi, I'm John Doe
```

So, what just happened here?

well, the first part created a new class, a new data type, Student. When called, through the dunder (from double underscore) method `__init__()`, it requires the name and surname parameters.

>[!note]- Methods vs Functions
>I've mentioned both methods and functions a bunch, and if you read this, they seem similar if not the same.
>The difference is really simple: If it's part of a class, it's a method. If it's on it's own, it's a class.
>That's it.
>That's the difference.

The class has a method, which you can call, called `presentation()`, which makes the Student represented by the class say who he is. To access data in the class from the method, you must need to prefix it with self, as it's it's own data.

See? Easy.

Well, as long as you don't start wondering about other dunder methods or making anything more complex. 

Unfortunately, if you want to do anything useful with this, you're going to need to do both so, here's some more stuff you can do:

- access a class' data from the outside: `classname.param` ex: `student.name`
- access a class' data from the inside using `self.param`
- call methods inside of methods, using `self.methodname`

As for dunder[^1] methods:

| method name      | params             | what do                                          |
| ---------------- | ------------------ | ------------------------------------------------ |
| `__init__()`     | self, initial data | It saves the initial data in the class           |
| `__str__()`      | self               | When the class is called as a string             |
| `__del__()`      | self               | What happens when the object gets removed        |
| `__trunc__()`    | self               | What happens when you truncate it (as number)    |
| `__ceil__()`     | self               | What happens when you ceiling[^2] it (as number) |
| `__floor__()`    | self               | same as ceil, but down                           |
| `__round__()`    | self               | same, but round it                               |
| `__add__()`      | self, other        | What happens when used with `+`.                 |
| `__sub__()`      | self, other        | same but `-`                                     |
| `__mul__()`      | self, other        | same but `*`                                     |
| `__floordiv__()` | self, other        | same but `//`                                    |
| `__truediv__()`  | self, other        | same but `/`                                     |
| `__mod__()`      | self, other        | same but `%`                                     |
| `__eq__()`       | self, other        | same but `==`                                    |
| `__ne__()`       | self, other        | same but `!=`                                    |
| `__gt__()`       | self, other        | same but `>`                                     |
| `__lt__()`       | self, other        | same but `<`                                     |
| `__le__()`       | self, other        | same but `<=`                                    |
| `__ge__()`       | self, other        | same but `>=`                                    |

for a longer list, look [here](https://www.geeksforgeeks.org/python/dunder-magic-methods-python/).


Classes can obviously interact with each other, like if you have a class Book, and you want to store it, you might want a class Library

[[3. Dictionaries|Previous]]
[[1. Introduction to algorithms|Next Chapter]]


[^1]:dunder methods are also sometimes called magic methods, so you don't get confused

[^2]:like rounding, but upwards
