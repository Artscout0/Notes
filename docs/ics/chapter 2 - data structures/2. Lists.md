
A list, is, well, a list of objects.
Every cell in a list can contain an object.
Every cell in the list has the same size in memory.

Now, how is it different from tuples?
Simple: mutability.

A tuple can not be modified, while a list can.
A list's length can be changed, it's elements replaced, and many other such things, while a tuple can not. 

to create a list is simple:

```python
a = [1, 2, 3]
print('list:', a)
```
```md
list: [1, 2, 3]
```

>[!tip]+ A convention
>A tuple is often used with multiple data types in it.
>
>A list is allowed to have multiple data types, however PEP8 and any developer worth their pay will yell at you for doing that. There is a reason why most other languages don't allow you to do that.

Lists, much like tuples, are also indexable, and iterable, which means you can access any specific element from them, and iterate over all of that.

## A small tangent on indexing and iteration

Indexing in python is a bit weird, as you can use a negative number for it.

The way it works is that `range(- len(lst), 0)` is functionally eequivalent to `range(0, len(lst)` (where lst is any list.) Basically, - length(list) is the first element of list.

Another thing that's worth talking about is slicing:

In a way oddly reminiscent of how range() works, you can slice a list.

if we take `l = [1,2,3,4,5]`, here  are some slices and their outputs:
```python
l[0:2]
```
```md
[1, 2]
```

```python
l[1:4]
```
```md
[2, 3, 4]
```

```python
l[0:5:2]
```
```md
[1, 3, 5]
```

```python
l[::-1]
```
```md
[5, 4, 3, 2, 1]
```

You therefore have:

start : end + 1 : step

>[!note]- If you want a real pythonism...
>In case you were paying attention, you might have noticed that a slice itself is technically an array (well, it returns one anyways...), which means you can take a slice of a slice.
>
>```python
>l = [1,2,3,4,5,6,7,8,9,10]
>print(l[::-1][3:7])
>``` 
>```md
>[7, 6, 5, 4]
>```

## elements `in` a list

A list in python has elements.

To check if an element is in a list, you use the `in` keyword.

To return true, it must exactly match an element in the list.

## List utilities

You can concatenate lists using the `+` operator, and you can concatenate them to themselves repeatedly using `*`.

Now, if you decided to try that with tuples, and you might have noticed it works.
Earlier, I said that tuples aren't mutable, and this seems to have modified it.

Why? What does that mean? How?

Well, to put it simply, under the hood, what happens is the following:

```python
t1 = (1, 2, 3)
t2 = (4, 5, 6)

# t1 += t2 # what happens here:
t1 = (1, 2, 3) + (4, 5, 6)
```

In reality, the original `t1` is still there in memory somewhere, but you just don't have a pointer for it (until a process called garbage collection anyway).

This is also what happens when you do that to lists, which is why next, we'll learn of some operations that allow us to work with that properly.

## How to properly edit lists

To change the value of an already existing element in a list is relatively easy.

```python
l = [1, 2, 3, 4]
print(l)

l[2] = 5
print(l)
```
```md
[1, 2, 3, 4]
[1, 2, 5, 4]
```

To make a list longer is also trivial:
```python
l = [1, 2, 3, 4]
print(l)

l.append(5)
print(l)
```
```md
[1, 2, 3, 4]
[1, 2, 3, 4, 5]
```

append is a method, so a function that gets called on an object (more about that later, if I haven't edited this by when we're taught this someone please remind me)

Technically you also have `l.insert(pos, val)`, which inserts a value at a specified position, but it's less used than append. If you insert too far away, it'll append it instead.

Just be careful, `l.append()` and `l.insert()` both only edit the list, they don't return anything.

>[!note]- A note on other langs...
>Python isn't the only one where functions that edit an object don't return anything.
>However, it's not something that's always the case.
>
>Among the languages I've used before, I know for a fact that for example JavaScript, a language I love to hate, returns the object it just edited, allowing you to compact something like
>```js
>list.push('elem1')
>list.push('elem2')
>list.push('elem3')
>```
>into
>```js
>list.push('elem1').add('elem2').add('elem3')
>```

If you want to edit a list, it's also fairly simple: you use the `l.pop` method.

```python
l = [1, 2, 3, 4]
r = l.pop()

print(l)
print(r)
```
`pop` is one of the methods that both edits and returns a value, the value being whatever you just removed.
```md
[1, 2, 3]
4
```

You can also pop at a specific index.

Another way to remove is by value, using the `remove` method.

```python
l = [1, 2, 3, 4, 3, 2, 1]
l.remove(3)

print(l)
```
```md
[1, 2, 4, 3, 2, 1]
```

Be careful, it only removes the first instance of it. To remove every instance, you can either use a while loop with `while elem in l:`, but there are also some other ways we won't mention for now.

Some other fun methods include:

These all work on indexable objects.

`l.extend(l2)` - it add all elements from l2 into l1 (+= uses it under the hood, but + doesn't, but don't use either.)
`l.count(val)` - it counts the number of occurrences of val in l.
`l.index(val)` - first index of val in l.
`len(l)` - length of l
`min` and `max` - the min and max value in the list

These only work on lists (well, mutable indexables).

`l.sort()` - it sorts the values in l. It's very powerful, especially if you learn to use it with it's optional parameters.
`l.reverse()` - reverses the list.

Lastly, using `list()` and `tuple()`, you can cast any indexable object into a list or a tuple.

[[1. What are data structures|Previous]]