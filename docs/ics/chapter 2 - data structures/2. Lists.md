
A list, is, well, a list of objects.
Every cell in a list can contain an object.
Every cell in the list has the same size in memory.

Now, how is it different from tuples?
Simple: mutability.

A tuple can not be modified, while a list can.
A list's length can be changed, it's elements replaced, and many other such things, while a tuple can not. 

to create a list is simple:

```python
a = [1, 2, 3]
print('list:', a)
```
```md
list: [1, 2, 3]
```

>[!tip]+ A convention
>A tuple is often used with multiple data types in it.
>
>A list is allowed to have multiple data types, however PEP8 and any developer worth their pay will yell at you for doing that. There is a reason why most other languages don't allow you to do that.

Lists, much like tuples, are also indexable, and iterable, which means you can access any specific element from them, and iterate over all of that.

## A small tangent on indexing and iteration

Indexing in python is a bit weird, as you can use a negative number for it.

The way it works is that `range(- len(lst), 0)` is functionally eequivalent to `range(0, len(lst)` (where lst is any list.) Basically, - length(list) is the first element of list.

Another thing that's worth talking about is slicing:

In a way oddly reminiscent of how range() works, you can slice a list.

if we take `l = [1,2,3,4,5]`, here  are some slices and their outputs:
```python
l[0:2]
```
```md
[1, 2]
```

```python
l[1:4]
```
```md
[2, 3, 4]
```

```python
l[0:5:2]
```
```md
[1, 3, 5]
```

```python
l[::-1]
```
```md
[5, 4, 3, 2, 1]
```

You therefore have:

start : end + 1 : step

>[!note]- If you want a real pythonism...
>In case you were paying attention, you might have noticed that a slice itself is technically an array (well, it returns one anyways...), which means you can take a slice of a slice.
>
>```python
>l = [1,2,3,4,5,6,7,8,9,10]
>print(l[::-1][3:7])
>``` 
>```md
>[7, 6, 5, 4]
>```

## elements `in` a list

A list in python has elements.

To check if an element is in a list, you use the `in` keyword.

To return true, it must exactly match an element in the list.

## List utilities

You can concatenate lists using the `+` operator, and you can concatenate them to themselves repeatedly using `*`.

Now, if you decided to try that with tuples, and you might have noticed it works.
Earlier, I said that tuples aren't mutable, and this seems to have modified it.

Why? What does that mean? How?

Well, to put it simply, under the hood, what happens is the following:

```python
t1 = (1, 2, 3)
t2 = (4, 5, 6)

# t1 += t2 # what happens here:
t1 = (1, 2, 3) + (4, 5, 6)
```

In reality, the original `t1` is still there in memory somewhere, but you just don't have a pointer for it (until a process called garbage collection anyway).

This is also what happens when you do that to lists, which is why next, we'll learn of some operations that allow us to work with that properly.

## How to properly edit lists

To change the value of an already existing element in a list is relatively easy.

```python
l = [1, 2, 3, 4]
print(l)

l[2] = 5
print(l)
```
```md
[1, 2, 3, 4]
[1, 2, 5, 4]
```

To make a list longer is also trivial:
```python
l = [1, 2, 3, 4]
print(l)

l.append(5)
print(l)
```
```md
[1, 2, 3, 4]
[1, 2, 3, 4, 5]
```

append is a method, so a function that gets called on an object (more about that later, if I haven't edited this by when we're taught this someone please remind me)

Technically you also have `l.insert(pos, val)`, which inserts a value at a specified position, but it's less used than append. If you insert too far away, it'll append it instead.

Just be careful, `l.append()` and `l.insert()` both only edit the list, they don't return anything.

>[!note]- A note on other langs...
>Python isn't the only one where functions that edit an object don't return anything.
>However, it's not something that's always the case.
>
>Among the languages I've used before, I know for a fact that for example JavaScript, a language I love to hate, returns the object it just edited, allowing you to compact something like
>```js
>list.push('elem1')
>list.push('elem2')
>list.push('elem3')
>```
>into
>```js
>list.push('elem1').add('elem2').add('elem3')
>```

If you want to edit a list, it's also fairly simple: you use the `l.pop` method.

```python
l = [1, 2, 3, 4]
r = l.pop()

print(l)
print(r)
```
`pop` is one of the methods that both edits and returns a value, the value being whatever you just removed.
```md
[1, 2, 3]
4
```

You can also pop at a specific index.

Another way to remove is by value, using the `remove` method.

```python
l = [1, 2, 3, 4, 3, 2, 1]
l.remove(3)

print(l)
```
```md
[1, 2, 4, 3, 2, 1]
```

Be careful, it only removes the first instance of it. To remove every instance, you can either use a while loop with `while elem in l:`, but there are also some other ways we won't mention for now.

Some other fun methods include:

These all work on indexable objects.

`l.extend(l2)` - it add all elements from l2 into l1 (+= uses it under the hood, but + doesn't, but don't use either.)
`l.count(val)` - it counts the number of occurrences of val in l.
`l.index(val)` - first index of val in l.
`len(l)` - length of l
`min` and `max` - the min and max value in the list

These only work on lists (well, mutable indexables).

`l.sort()` - it sorts the values in l. It's very powerful, especially if you learn to use it with it's optional parameters.
`l.reverse()` - reverses the list.

Lastly, using `list()` and `tuple()`, you can cast any indexable object into a list or a tuple.


## A very brief tangent on matrices

A matrix in python is fairly simple. It is a list... of lists.

```python
m = [[1,2,3],[4,5,6],[7,8,9]]
```

That's about it.

## Lists in memory

lists also have the `l.copy()` method. It creates a copy of the list.

If you copy a list of lists, and *change out* one of the original sub-lists, it won't affect the new one, which is good.

```python
L1 = [[1,2],[3,4]]
L2 = L1.copy()
L1[0] = [1,2,5]
```

However, if you *modify* the list,  it will affect the copy.

```python
L1 = [[1,2],[3,4]]
L2 = L1.copy()
L1[0].append(5)
```

Why? because of memory.

lists in python only store pointers, references.

Which means, if you copy a list, it'll be an exact copy, because it points to the same stuff in memory.

If you change out the list, it'll only affect L1, because what you're really doing is changing where it's pointing.

If you however modify the data it's pointing to (because of mutability, so using something like `.append()`), it doesn't change where the list is pointing. Only what's being pointed at. And because the second list points to the same places at the first one, what it's pointing to also changed.

Basically:

lists point to stuff.

In one case, you change what it's pointing to.

In the other, you change the thing that is being pointed to.

In the first case, copies still point to the original, remaining from outside unchanged.
In the second, copies still point to the original, which has changed, from the outside seeming changed.

## List comprehension

Lists are annoying to work with. Which is why python added list comprehension, which is essentially a loop with hidden appends in them.

An example
```python
L1 = []
for i in range(1, 5):
	L1.append( i ** 2)
```

is equivalent to

```python
L2 = [x**2 for x in range(1, 5)]
```

and both result in

```md
[1, 4, 9, 16]
```


List comprehension makes sense if you read it out like:

we get a list, with for every element in `range(1, 5)`, the square of that element in the list.

If you want [[4. Conditionality|conditions]] in the loop, you can add that like this:

```python
s = "This is a bit of text, it's very texty"

L = [c for c in s if c in 'aeiou']
```

It's equivalent to

```python
s = "This is a bit of text, it's very texty"

L = []
for c in s:
	if c in 'aeiou':
		L.append(c)
```

You can even add multiple lists in a single comprehension, but if you need to do that, you're doing something wrong. I don't know what, but definitely something.

[[1. What are data structures|Previous]]
[[3. Dictionaries|Next]]